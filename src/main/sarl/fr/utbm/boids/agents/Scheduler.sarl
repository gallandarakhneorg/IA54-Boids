package fr.utbm.boids.agents

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.DefaultContextInteractions
import fr.utbm.boids.events.IsStarted
import io.sarl.core.Lifecycle
import fr.utbm.boids.events.StartingSimulation
import fr.utbm.boids.events.NeedDataBoids
import io.sarl.core.Schedules
import fr.utbm.boids.events.SendDataBoids
import fr.utbm.boids.events.BoidsToDisplay
import fr.utbm.boids.gui.BoidsFxViewerController
import io.sarl.core.Time
import fr.utbm.boids.gui.fx.EndSimulation
import fr.utbm.boids.events.SchedulerBeginsScheduling

agent Scheduler {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
	
	var online : boolean // if the simulation is online or not
	var ctrl : BoidsFxViewerController = null
	
	//fréquence de rafraichissement en millisecondes
	var freqRafraichissement : long
	var Time : Time
	var lastUpdate : long
	
	/*
	 * gestion des évènements
	 */

	on Initialize {
		loggingName = "Scheduler-" + this.ID
		info("The Scheduler is started.")
		ctrl = occurrence.parameters.get(0) as BoidsFxViewerController
		emit(new IsStarted("Scheduler"))
	}

	//on StartingSimulation {
	on SchedulerBeginsScheduling {
		info("HEY")
		online = true
		//this.freqRafraichissement = occurrence.freqRafraichissement
		this.freqRafraichissement = occurrence.freqRafraichissement * 100
		//info(freqRafraichissement)

		//in(this.freqRafraichissement) [
		in(1000) [
			info("je demande")
			emit(new NeedDataBoids())
			//lastUpdate = Time.getTime()
			//lastUpdate = System.currentTimeMillis() 
/* 
			in(this.freqRafraichissement) [
				info("je redemande")
			emit(new NeedDataBoids())
			 * ]
			 */
			in(1000) [task('Scheduling').every(50) [
				info("je demande")
				emit(new NeedDataBoids())
			]
		]]

		/*while (true) {

			if (System.currentTimeMillis() - lastTimeUpdate < updateFrequency) {
				try {
					Thread.sleep(lastTimeUpdate - System.currentTimeMillis() + updateFrequency + 2); 	// +2 avoids update time check to fail
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				try {
					Thread.sleep(2);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			update();

		}*/
	
		/*while(online){
			info("on est dans le while du cycle", 0)
			System.currentTimeMillis() 
			//info(Time.Instant)
			info(lastUpdate)
			info(freqRafraichissement)
			if (System.currentTimeMillis() >= lastUpdate + freqRafraichissement) {
				info("je demande")
				emit(new NeedDataBoids())
				//lastUpdate = Time.getTime()
			} else {
				
			}
		}*/
		
		/*task('Scheduling').every(1000) [
			info("je demande")
			emit(new NeedDataBoids())
		]*/

		
		/*while(online){		//need synchronized?
			in(this.freqRafraichissement)[
				info("je demande")
				emit(new NeedDataBoids())
			]
		}*/
	}

	on SendDataBoids{
		info(occurrence.lesBoids)
	}
	
	on BoidsToDisplay{
		info("j'ai reçu des boids à afficher : " + occurrence.boids)
		for (mesBoids : occurrence.boids.entrySet) {
			info("boid position : " + mesBoids.value.position)
		}
		ctrl.updateGraphics(occurrence.boids.values)
	}

	on EndSimulation {
		info('Scheduler kill')
		online = false
		task('Scheduling').cancel
		killMe
	}

	on Destroy {
	}
	
}