package fr.utbm.boids.agents

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.DefaultContextInteractions
import fr.utbm.boids.events.IsStarted
import io.sarl.core.Lifecycle
import fr.utbm.boids.events.NeedDataBoids
import io.sarl.core.Schedules
import fr.utbm.boids.events.SendDataBoids
import fr.utbm.boids.gui.BoidsFxViewerController
import io.sarl.core.Time
import fr.utbm.boids.gui.fx.EndSimulation
import fr.utbm.boids.events.SchedulerBeginsScheduling
import io.sarl.core.Behaviors
import fr.utbm.boids.events.BoidsToDisplay

agent TimeManager {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules, Behaviors
	
	var online : boolean // if the simulation is online or not
	var ctrl : BoidsFxViewerController = null
	
	//fréquence de rafraichissement en millisecondes
	var freqRafraichissement : long
	var Time : Time
	var lastUpdate : long
	
	// var iteration : int
	// var boidsIteration : int
	// var tempBoids : Map<UUID, BoidBody>
	
	/*
	 * gestion des évènements
	 */

	on Initialize {
		loggingName = "Scheduler-" + this.ID
		info("The Scheduler is started.")
		ctrl = occurrence.parameters.get(0) as BoidsFxViewerController
		emit(new IsStarted("Scheduler"))
		// iteration = 0
		// boidsIteration = 0
	}

	//on StartingSimulation {
	on SchedulerBeginsScheduling {
		info("HEY")
		online = true
		//this.freqRafraichissement = occurrence.freqRafraichissement
		this.freqRafraichissement = occurrence.freqRafraichissement * 100
		//info(freqRafraichissement)

		//in(this.freqRafraichissement) [
		in(1000) [
			// iteration++
			info("je demande")
			emit(new NeedDataBoids())
			//lastUpdate = Time.getTime()
			//lastUpdate = System.currentTimeMillis() 
/* 
			in(this.freqRafraichissement) [
				info("je redemande")
			emit(new NeedDataBoids())
			 * ]
			 */
			in(1000) [task('Scheduling').every(50) [
				// info('Iteration actuelle: ' + iteration + ', boidsIteration: ' + boidsIteration)
				// if(iteration == boidsIteration) {
					// iteration++
					info("je demande")
					emit(new NeedDataBoids())
				// } else if(boidsIteration != 0) {
					//iteration++
					//boidsIteration = iteration - 1
					//wake(new BoidsToDisplay(tempBoids))
				// }
			]
		]]

		/*while (true) {

			if (System.currentTimeMillis() - lastTimeUpdate < updateFrequency) {
				try {
					Thread.sleep(lastTimeUpdate - System.currentTimeMillis() + updateFrequency + 2); 	// +2 avoids update time check to fail
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				try {
					Thread.sleep(2);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			update();

		}*/
	
		/*while(online){
			info("on est dans le while du cycle", 0)
			System.currentTimeMillis() 
			//info(Time.Instant)
			info(lastUpdate)
			info(freqRafraichissement)
			if (System.currentTimeMillis() >= lastUpdate + freqRafraichissement) {
				info("je demande")
				emit(new NeedDataBoids())
				//lastUpdate = Time.getTime()
			} else {
				
			}
		}*/
		
		/*task('Scheduling').every(1000) [
			info("je demande")
			emit(new NeedDataBoids())
		]*/

		
		/*while(online){		//need synchronized?
			in(this.freqRafraichissement)[
				info("je demande")
				emit(new NeedDataBoids())
			]
		}*/
	}

	on SendDataBoids{
		info(occurrence.lesBoids)
	}
	
	on BoidsToDisplay{
		info("j'ai reçu des boids à afficher : " + occurrence.boids)
		for (mesBoids : occurrence.boids.entrySet) {
			info("boid position : " + mesBoids.value.position)
		}
		ctrl.updateGraphics(occurrence.boids.values)
		// tempBoids = occurrence.boids
		// boidsIteration++
	}

	//on EndSimulation [!isFromMe] {
	on EndSimulation {
		 info('Scheduler kill')
		online = false
		task('Scheduling').cancel
		//in(1000) [killMe]
		killMe
	}

	on Destroy {
	}
	
}