package fr.utbm.boids.agents

import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.DefaultContextInteractions
import fr.utbm.boids.events.DemandeDeplacement
import fr.utbm.boids.events.StartPosition
import fr.utbm.boids.events.ResultatDeplacement
import java.util.Random
import fr.utbm.boids.events.ValidationDeplacement
import fr.utbm.boids.BoidBody
import fr.utbm.boids.environment.Obstacle
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import javafx.geometry.Point2D
import io.sarl.core.Lifecycle
import java.util.UUID
import fr.utbm.boids.gui.fx.EndSimulation
import java.util.Map
import fr.utbm.boids.events.BoidInitialized
import fr.utbm.boids.EnvInfos
import java.util.HashMap
import fr.utbm.boids.events.PositionModification
import java.util.List
import fr.utbm.boids.util.LineTool
import fr.utbm.boids.util.Coordinates
import fr.utbm.boids.Vector

agent Boid {
	uses Logging, DefaultContextInteractions, Lifecycle

	/* 3aboqphié/3πR² = 3qbc */

	var body : BoidBody
	var parentAgent : UUID
	var envInfos : EnvInfos
	var visibleBoids : Map<UUID, BoidBody>
	var closeBoids : Map<UUID, BoidBody>
	
	/*
	 * gestion des évènements
	 */
	 
	on Initialize {
		loggingName = "Boid-" + this.ID
		info("A Boid agent was started.")
		parentAgent = occurrence.spawner
		this.body = new BoidBody(this.ID, occurrence.parameters.get(0) as Integer, occurrence.parameters.get(1) as Integer, occurrence.parameters.get(2) as Integer, occurrence.parameters.get(3) as Integer, occurrence.parameters.get(4) as Integer)
		this.envInfos = occurrence.parameters.get(5) as EnvInfos
		this.visibleBoids = new HashMap<UUID, BoidBody>
		this.closeBoids = new HashMap<UUID, BoidBody>
		emit(new BoidInitialized(this.body, 'Boid'))
	}
	
	on StartPosition {
		var validPosition : AtomicBoolean = new AtomicBoolean(true)
		var maPosition : Vector
		var rnd = new Random()
		var x : AtomicInteger = new AtomicInteger(0)
		var y : AtomicInteger = new AtomicInteger(0)
		var vx : AtomicInteger = new AtomicInteger(0)
		var vy : AtomicInteger = new AtomicInteger(0)	
		do {
			validPosition.set(true)
			x.set(rnd.nextInt(envInfos.width) + 1)
			y.set(rnd.nextInt(envInfos.height) + 1)
			occurrence.obstacles.forEach[o : Obstacle, index : int | 
				if(o.getPolygon().contains(new Point2D(x.get(), y.get()))) {
					validPosition.set(false)
				}
			]
		} while(validPosition.get() == false)
		
		maPosition = new Vector(x.get(), y.get())
		
		//définition d'une vitesse aléatoire 
		vx.set(rnd.nextInt(this.body.groupeVitesseMax))
		vy.set(rnd.nextInt(this.body.groupeVitesseMax))
		this.body.newVitesse = new Vector (vx.get(),vy.get())
		
		// vmax est en ligne droite, on vérifie qu'avec vx et vy on dépasse pas la longueur de vmax
		if (this.body.newVitesse.length > this.body.groupeVitesseMax) {
			this.body.newVitesse.normaliser()
			this.body.newVitesse.fois(this.body.groupeVitesseMax)
		}
		
		emit(new ResultatDeplacement(maPosition, this.body.newVitesse))
	}

	// Si le déplacement est validé, on enregistre la nouvelle position du Boids, ainsi que sa nouvelle vitesse
	on ValidationDeplacement {
		this.body.position = occurrence.position
		this.body.vitesse = this.body.newVitesse
	}
	
	@SuppressWarnings("equals_with_null")
	on DemandeDeplacement {
		
		var boids = occurrence.boids
		var forceTot : Vector

		forceTot = new Vector(0, 0)
		
		visibleBoids = perception(boids, 'visible')
		closeBoids = perception(boids, 'close')
		 
		if (boids != null) {
			
			//on applique la séparation 
			forceTot.plus(separation(visibleBoids))
			
			//on applique la cohésion
			forceTot.plus(cohesion(closeBoids))				
			
			//on applique l'alignement
			forceTot.plus(alignement(closeBoids))

			//on applique la répulsion
			forceTot.plus(repulsion(closeBoids))
			
			// on applique la force résultant de la détection des obstacles
			forceTot.plus(forceObstacles(occurrence.obstacles))
		 
			// TODO appliquer force obstacle
		}
		
		//forceTot.fois(100000)
		//info("force totale " + forceTot)

		emit(new ResultatDeplacement(appliquerForce(forceTot), this.body.newVitesse))
	 
	}
	
	/*
	 * fonction qui permet de déterminer si le boids en question est visible dans notre perception
	 */
	 
	 def visible (b : BoidBody) : boolean{
	 	
	 	var tmp : Vector
	 	var tmp2 : Vector
	 	
	 	
	 	tmp = new Vector(b.position)
	 	tmp.moins(this.body.position)
	 	
		/*if (tmp.x > envInfos.width/2 ){
	 		tmp.moins(new Vector(envInfos.width,0))
	 	}
	 	
	 	if (tmp.y > envInfos.height/2) {
	 		tmp.moins(new Vector(0,envInfos.height))
	 	}*/
	 	
	 	
	 	// Si le boids est trop loin, on ne le voit pas 
	 	if (tmp.length() > this.body.distanceVisibilite){
	 		return false
	 	}
	 	
	 	tmp2 = new Vector(this.body.vitesse)
	 	
	 	// on test si le boids est hors de l'angle de vision : cos(ABC) = vec(AB).vec(AC)/(AB*AC)
	 	if (Math.abs(Math.toDegrees(Math.acos((tmp2.point(tmp)/(tmp2.length * tmp.length))))) > this.body.angleVisibilite) {
	 		return false
	 	}
	 	
	 	return true
	 }

	def proche(b : BoidBody) : boolean {
		var tmp : Vector

		tmp = new Vector(b.position)
		tmp.moins(this.body.position)
		if (tmp.length() > this.body.distanceVisibilite) {
			return false
		}
		return true
	}
	 
	
	/* 
	 * Création des fonctions comportementales du Boids
	 */
	 
	@SuppressWarnings("equals_with_null")
	def separation(boids : Map<UUID, BoidBody>) : Vector {

		var force : Vector
		var tmp : Vector
		var len : double
		var xelem : double
		var yelem : double
		var tmpelem : Vector

		force = new Vector(0, 0)
		tmp = new Vector(0, 0)
		 
		for (elem : boids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe) {
				
				/*if(distance(this.body.position.x, elem.value.position.x) < distance(this.body.position.x, elem.value.position.x - envInfos.width)){
					if(distance(this.body.position.x, elem.value.position.x) < distance(this.body.position.x, elem.value.position.x + envInfos.width)){
						xelem = elem.value.position.x
					} else {
						xelem = elem.value.position.x + envInfos.width
					}
				} else {
					if(distance(this.body.position.x, elem.value.position.x - envInfos.width) < distance(this.body.position.x, elem.value.position.x + envInfos.width)){
						xelem = elem.value.position.x - envInfos.width
					} else {
						xelem = elem.value.position.x + envInfos.width
					}
				}
				
				if (distance(this.body.position.y, elem.value.position.y) < distance(this.body.position.y, elem.value.position.y - envInfos.height)) {
					if (distance(this.body.position.y, elem.value.position.y) < distance(this.body.position.y, elem.value.position.y + envInfos.height)) {
						yelem = elem.value.position.y
					} else {
						yelem = elem.value.position.y + envInfos.height
					}
				} else {
					if (distance(this.body.position.y, elem.value.position.y - envInfos.height) < distance(this.body.position.y, elem.value.position.y + envInfos.height)) {
						yelem = elem.value.position.y - envInfos.height
					} else {
						yelem = elem.value.position.y + envInfos.height
					}
				 }*/
					 
				
				tmpelem = new Vector(xelem%envInfos.width, yelem%envInfos.height)
				tmp.setXY(this.body.position)
				//tmp.moins(tmpelem)
				tmp.moins(elem.value.position)
				len = tmp.length()
				tmp.fois(1 / (len * len))
				force.plus(tmp)
				//force.fois(35)
			}
		}
	
		return force

	}

	@SuppressWarnings("equals_with_null")
	def cohesion(boids : Map<UUID, BoidBody>) : Vector {
		
		var nbTot = 0 
		var force : Vector 
		
		force = new Vector(0,0)
		 
		for (elem : boids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe) {
				nbTot++
				force.plus(elem.value.position)
			}
		}
		
		if (nbTot > 0){
			force.fois(1/nbTot)
			force.moins(this.body.position)
		}
		force.fois(0.45)
		return force
	}
	
	

	@SuppressWarnings("equals_with_null")
	def alignement(boids : Map<UUID, BoidBody>) : Vector {
		
		var nbTot = 0 
		var force : Vector
		var tmp : Vector
		
		force = new Vector(0,0)
		tmp = new Vector(0,0)

		for (elem : boids.entrySet) {
			if (elem.key != null && elem.value.groupe == this.body.groupe) {
				nbTot++
				tmp.setXY(elem.value.position)
				tmp.fois(1 / tmp.length)
				force.plus(tmp)
			}
		}
		
		if (nbTot > 0) {
			force.fois(1/nbTot)	
		}
		force.fois(50)
		return force
		
	}

	@SuppressWarnings("equals_with_null")
	def repulsion(boids : Map<UUID, BoidBody>) : Vector {
		
		var force : Vector
		var tmp : Vector
		var len : double
		
		force = new Vector(0,0)
		tmp = new Vector(0,0)

		for (elem : boids.entrySet) {
			if (elem.key != null && elem.value.groupe != this.body.groupe) {
				tmp.setXY(this.body.position)
				tmp.moins(elem.value.position)
				len = tmp.length
				tmp.fois(1 / (len * len))
				force.plus(tmp)
				force.fois(100)
			}
		}
		
		return force
	}
	
	def forceObstacles(listeObstacles : List<Obstacle>) : Vector{
		
		var forceObstacles : Vector = new Vector(0, 0)
		
		/*var direction = new Vector(0,0)
		var direction2 = new Vector(0,0)
		var tmp = new Vector(0,0)
		var collision : Vector = new Vector(this.body.vitesse)*/
		
		if (listeObstacles !== null) {
			listeObstacles.forEach [ o : Obstacle, index : int |
				//if(obstacleProche(o))
				//if(index == 0){
				if (obstacleVisible(o)) {
					var direction : Vector
					// V1
					/*direction = new Vector(o.getCenter())
					direction.moins(this.body.position)
					direction.normaliser
					forceObstacles.plus(direction)
					*/
					// V2
/*					var pointLePlusProche : Vector = new Vector(1000, 1000)
					for(line :  o.lines){
						var pointATester : Vector
						pointATester = new Vector(line.getA())
						pointATester.moins(this.body.position)
						if(pointATester.length < pointLePlusProche.length){
							pointLePlusProche = pointATester
						}
					}
					direction = new Vector(pointLePlusProche)
					direction.normaliser
					forceObstacles.moins(direction)
*/
					// V3
					var pointLePlusProche : Vector = new Vector(1000, 1000)
					var pointLePlusProcheDeuxieme : Vector = new Vector(1000, 1000)
					var pointLePlusProcheTroisieme : Vector = new Vector(1000, 1000)
					var indexLine : int = 0
					for (line : o.lines) {
						indexLine = index + 1
						var pointATester : Vector
						pointATester = new Vector(line.getB())
						pointATester.moins(this.body.position)
						if (pointATester.length < pointLePlusProche.length) {
							pointLePlusProche = pointATester
					 		pointLePlusProcheDeuxieme = new Vector(line.getA())
					 		pointLePlusProcheTroisieme = new Vector(o.lines.get((indexLine + 1)%o.lines.size).getB())
						}
					}
					var forcetmp : Vector
					forcetmp = new Vector(pointLePlusProche)
					forcetmp.moins(this.body.position)
					forcetmp.normaliser
					// tester si normalisation avant/après change
					forceObstacles.moins(forcetmp)

					forcetmp = new Vector(pointLePlusProcheDeuxieme)
					forcetmp.moins(this.body.position)
					forcetmp.normaliser
					forceObstacles.moins(forcetmp)

					forcetmp = new Vector(pointLePlusProcheTroisieme)
					forcetmp.moins(this.body.position)
					forcetmp.normaliser
					forceObstacles.moins(forcetmp)
					
					// V4
					/*var pointLePlusProche : Vector = new Vector(1000, 1000)
					var pointLePlusProcheDeuxieme : Vector = new Vector(1000, 1000)
					var pointLePlusProcheTroisieme : Vector = new Vector(1000, 1000)
					var indexLine : int = 0
					var pointATester : Vector = new Vector(0,0)
					for (line : o.lines) {
						indexLine = index + 1
						pointATester = new Vector(line.getB())
						pointATester.moins(this.body.position)
						if (pointATester.length < pointLePlusProche.length) {
							pointLePlusProche = pointATester
							pointLePlusProcheDeuxieme = new Vector(line.getA())
							pointLePlusProcheTroisieme = new Vector(o.lines.get((indexLine + 1)%o.lines.size).getB())
						}
					} 
					var ligne : Vector
					ligne = new Vector(pointLePlusProcheDeuxieme)
					ligne.moins(pointLePlusProcheTroisieme)
					var forceNormale : Vector
					var vecteurUnitaireZ = new Vector(0.0f,0.0f,1)
					forceNormale = ligne.produitVectoriel(vecteurUnitaireZ)
					//forceNormale.normaliser
					forceObstacles.plus(forceNormale)
					info(forceNormale)*/
					
					//V5
					/*tourner sur soi meme jusqu'a avoir un champ de vision degagé
					 * + réduire champ de vision petit a petit */
				}
				
				
				
				
				
				
				
				
					/*direction.plus(o.getCenter())
					direction2.plus(new Vector(this.body.position.x, this.body.position.y))
					direction.moins(direction2)
					tmp.plus(direction)
					tmp.normaliser
					force.moins(tmp)
				}*/
				 
				// Si le boid vient de droite, répulsion vers la droite, si il vient de la gauche, répulsion vers la gauche, si il vient du haut, répulsion vers le haut, si il vient du bas, répulsion vers le bas.
				// --> Diviser la bouding box(carré) en 4 parties haut bas gauche droite pour discerner ces cas
				// Appliquer une force dans pour faire partir le boids dans la direction inverse
				/*if(this.body.position.y <= o.polygon.boundsInLocal.maxY - 50) {
					if (o.polygon.boundsInLocal.contains(this.body.position.x, this.body.position.y)) {
						force.plus(o.center)
						force.normaliser()
					} 
				} else if(this.body.position.y >= o.polygon.boundsInLocal.minY + 50) {
					if (o.polygon.boundsInLocal.contains(this.body.position.x, this.body.position.y)) {
						force.moins(o.center)
						force.normaliser()
					}
				}*/
				
			]
		}
		forceObstacles.fois(100)
		return forceObstacles
	}
	
	def obstacleVisible(obstacle : Obstacle) : boolean {
		var obstacleTrouve : boolean = false
		
		for(line : obstacle.lines){
		
		//obstacle.lines.forEach[line : LineTool , index : int |
			
			//info("obstacle : " + obstacle)
			//info("ligne : " + index)
			//calcul delta = r² * dr² - D²
			var delta : double = 0
			//calcul r
			var r : double = 0
			//info("visibilité : " + this.body.distanceVisibilite)
			r = this.body.distanceVisibilite
			//info("r2 : " + r2)
			//calcul dr
			var dr : double = 0
			var dx : double = 0
			var dy : double = 0
			var tmp1 : double = 0
			var tmp2 : double = 0
			//info(line.getA().getX())
			tmp1 = line.getB().getX()
			tmp1 = tmp1 - this.body.position.x
			//info("tmp1 : " + tmp1)
			tmp2 = line.getA().getX()
			tmp2 = tmp2 - this.body.position.x
			//info("tmp2 : " + tmp2)
			dx = tmp1 - tmp2
			//info(dx)
			tmp1 = line.getB().getY()
			tmp1 = tmp1 - this.body.position.y
			tmp2 = line.getA().getY()
			tmp2 = tmp2 - this.body.position.y
			dy = tmp1 - tmp2
			dr = Math.sqrt(dx * dx + dy * dy)
			
			//calcul D
			var D : double = 0
			D = (line.getA().getX() - this.body.position.x) * (line.getB().getY() - this.body.position.y) -
				(line.getB().getX() - this.body.position.x) * (line.getA().getY()- this.body.position.y)
			delta = Math.pow(r,2) * Math.pow(dr,2) - Math.pow(D,2)
			//info(delta)
			if(delta > 0){
				// calcul des coordonnées des deux points
				var pointIntersectionAX : double
				var pointIntersectionAY : double
				var pointIntersectionBX : double
				var pointIntersectionBY : double
				
				// (D * dy +- sgn(dy) * dx * sqrt(r² * dr² - D²)) / dr²
				// A
				if(dy < 0){
					pointIntersectionAX = D * dy - dx * Math.sqrt(delta)
				} else {
					pointIntersectionAX = D * dy + dx * Math.sqrt(delta)
				}
				pointIntersectionAX = pointIntersectionAX / Math.pow(dr,2)

				// B
				if (dy < 0) {
					pointIntersectionBX = D * dy + dx * Math.sqrt(delta)
				} else {
					pointIntersectionBX = D * dy - dx * Math.sqrt(delta)
				}
				pointIntersectionBX = pointIntersectionBX / Math.pow(dr, 2)
				
				// (-D * dx +- |dy| * sqrt(r² * dr² - D²)) / dr²
				// A
				pointIntersectionAY = -D * dx + Math.abs(dy) * Math.sqrt(delta)
				pointIntersectionAY = pointIntersectionAY / Math.pow(dr, 2)

				// B
				pointIntersectionBY = -D * dx - Math.abs(dy) * Math.sqrt(delta)
				pointIntersectionBY = pointIntersectionBY / Math.pow(dr, 2)
				
				//info("A : " + pointIntersectionAX + ", " + pointIntersectionAY)
				//info("B : " + pointIntersectionBX + ", " + pointIntersectionBY)
				var pointA : Vector
				var pointB : Vector
				pointA = new Vector(pointIntersectionAX + this.body.position.x, pointIntersectionAY + this.body.position.y)
				pointB = new Vector(pointIntersectionBX + this.body.position.x, pointIntersectionBY + this.body.position.y)
				
				
				
				//vérifier si un des points est sur le segment
				if (pointA.getX() < line.getA().getX() && pointA.getX() > line.getB().getX() ||
					pointA.getX() > line.getA().getX() && pointA.getX() < line.getB().getX()) {
					//info("OBSTACLE : " + pointB)
					var AB : Vector
					var BC : Vector
					AB = new Vector(this.body.vitesse)
					pointA.moins(this.body.position)
					BC = new Vector(pointA)
					if (Math.abs(Math.toDegrees(Math.acos(AB.point(BC) / (AB.length * BC.length)))) <
						this.body.angleVisibilite) {
						obstacleTrouve = true
					}
				}
				if (pointB.getX() < line.getA().getX() && pointB.getX() > line.getB().getX() ||
					pointB.getX() > line.getA().getX() && pointB.getX() < line.getB().getX()) {
					// info("OBSTACLE : " + pointB)
					var AB : Vector
					var BC : Vector
					AB = new Vector(this.body.vitesse)
					pointB.moins(this.body.position)
					BC = new Vector(pointB)
					if (Math.abs(Math.toDegrees(Math.acos(AB.point(BC) / (AB.length * BC.length)))) <
						this.body.angleVisibilite) {
						obstacleTrouve = true
					}
				}
			}
		}//]
		if(obstacleTrouve == true){
			return true
		} else {
			return false
		}
		/*
		info(obstacle.lines.length)
		var tmp : Vector
		tmp = obstacle.getCenter()
		//info(tmp)
		tmp.moins(this.body.position)
		//info(tmp)
		if(tmp.length < this.body.distanceVisibilite){
			return true
		} else {
			return false
		 * }
		 */
		/* 
		var absolu : double
		
		if (Math.abs(Math.toDegrees(Math.acos((tmp2.point(tmp) / (tmp2.length * tmp.length))))) >
			this.body.angleVisibilite) {
			return false
	 	}
		*/
		
		
		
	}
	
	def obstacleProche (obstacle : Obstacle){
		var proche = false
		var test : Vector
		for(var i : int = 0;i < obstacle.nbPoints();i++){
			info(obstacle.polygon.points.get(i))
			test = new Vector(obstacle.polygon.points.get(i*2) - this.body.position.x,
				obstacle.polygon.points.get(i*2 + 1) - this.body.position.y)
			if(test.length < this.body.distanceVisibilite * 2){
				proche = true
			}
		}
		return proche
	}
	
	// retourne la position du boid après l'application de la force, stoque en mémoire la nouvelle vitesse du Boids
	def appliquerForce(force : Vector) : Vector {

		// f = ma => a =f/m

		var newPosition : Vector		
		var acceleration : Vector

		if (force.length > 1.7) {
			force.normaliser()
			force.fois(1.7)
		}
		
		acceleration = new Vector(force)
		//acceleration.fois(1/this.body.masse)
		
		this.body.newVitesse = new Vector(this.body.vitesse)
		this.body.newVitesse.plus(acceleration)
		
		//bornage de la vitesse
		if (this.body.newVitesse.length > this.body.groupeVitesseMax){
			this.body.newVitesse.normaliser()
			this.body.newVitesse.fois(this.body.groupeVitesseMax)
		}
		
		//maj position
		newPosition = new Vector(this.body.position)
		newPosition.plus(this.body.newVitesse)
		return newPosition
	}
	
	def distance(XA : double, XB : double){
		return Math.abs(XA - XB)
	}
	
	on EndSimulation [isFrom(this.parentAgent)] {
		emit(new EndSimulation) [it.UUID == this.parentAgent]
		killMe
	}
		
	def perception(boids : Map<UUID, BoidBody>, mode : String) : Map<UUID, BoidBody> {
		if (mode === 'visible') {
			visibleBoids.clear()
			for (elem : boids.entrySet) {
				if (elem.key !== null && visible(elem.value) && elem.key != this.ID) {
					visibleBoids.put(elem.key, elem.value)
				}
			}
			return visibleBoids
		} else if (mode === 'close') {
			closeBoids.clear()
			for (elem : boids.entrySet) {
				if (elem.key !== null && proche(elem.value) && elem.key != this.ID) {
					closeBoids.put(elem.key, elem.value)
				}
			}
			return closeBoids
		}
		
	}
	
	on PositionModification {
		this.body.position.x = occurrence.x
		this.body.position.y = envInfos.height - occurrence.y
	}
	
}
