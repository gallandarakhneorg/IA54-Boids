package fr.utbm.boids.gui

import fr.utbm.boids.gui.fx.FxViewerController
import javafx.fxml.FXML
import fr.utbm.boids.events.ConfigureSimulation
import javafx.scene.control.Label
import javafx.scene.control.ScrollBar
import javafx.scene.control.Button
import javafx.scene.Group
import javafx.scene.layout.Pane
import javafx.application.Platform
import javafx.scene.shape.Polygon
import fr.utbm.boids.util.Coordinates
import fr.utbm.boids.util.LineTool
import com.google.common.util.concurrent.AtomicDouble
import java.util.ArrayList
import java.util.List
import fr.utbm.boids.environment.Obstacle
import fr.utbm.boids.BoidBody
import java.util.Collection
import javafx.scene.shape.Circle
import javafx.scene.paint.Color
import fr.utbm.boids.Configuration
import javafx.scene.control.ToggleButton
import javafx.scene.layout.Background
import javafx.scene.layout.BackgroundFill
import javafx.scene.layout.CornerRadii
import javafx.geometry.Insets
import javafx.scene.effect.Glow
import javafx.scene.input.MouseEvent
import javafx.^event.EventHandler
import javafx.scene.shape.Rectangle
import fr.utbm.boids.events.Pause
import fr.utbm.boids.events.Resume

class BoidsFxViewerController extends FxViewerController  {

	var launched = false
	var mapCreated = false

	@FXML var main_pane : Pane
	@FXML var boids_group : Group // Groupe contenant les boids
	@FXML var UI_pane : Pane // Pane contenant l'UI
	@FXML var obstacle_group : Group // Groupe contenant les obstacles
	
	@FXML var toggle_night_mode : ToggleButton
	@FXML var toggle_perception : ToggleButton
	@FXML var start_button : Button
	@FXML var night_mode_indicator : Circle
	@FXML var perception_indicator : Circle

	// Titres
	@FXML var boids_quantity_label : Label
	@FXML var map_selection_label : Label
	@FXML var boids_population_label : Label
	@FXML var boids_vision_label : Label
	@FXML var boids_distance_deplacement_label : Label

	// Sliders
	@FXML var boids_quantity_input : ScrollBar
	@FXML var map_selection_input : ScrollBar
	@FXML var boids_population_input : ScrollBar
	@FXML var boids_vision_input : ScrollBar
	@FXML var boids_distance_deplacement_input : ScrollBar

	// Valeurs
	@FXML var boids_quantity_display : Label
	@FXML var map_selection_display : Label
	@FXML var boids_population_display : Label
	@FXML var boids_vision_display : Label
	@FXML var boids_distance_deplacement_display : Label
	
	@FXML var boids_quantity_min : Label
	@FXML var boids_quantity_max : Label
	@FXML var map_min : Label
	@FXML var map_max : Label
	@FXML var boids_population_min : Label
	@FXML var boids_population_max : Label
	@FXML var boids_vision_min : Label
	@FXML var boids_vision_max : Label
	@FXML var boids_distance_deplacement_min : Label
	@FXML var boids_distance_deplacement_max : Label
	
	// TODO coder la pause/reprise et l'affichage des infos au vol
	@FXML var pause_button : Rectangle
	@FXML var resume_button : Polygon
	@FXML var boid_group : Label
	@FXML var boid_vitesse : Label
	@FXML var boid_new_vitesse : Label
	@FXML var boid_group_vitesse : Label
	@FXML var boid_angle : Label
	@FXML var boid_distance : Label
	@FXML var boid_masse : Label
	@FXML var hide_infos : Button
	@FXML var boids_infos_pane : Pane

	var polygons : List<Polygon>
	var polygonsCoordinates : List<List<Coordinates>>
	var obstacles : List<Obstacle> = new ArrayList()
	var nightMode : Boolean = false
	var togglePerception : Boolean = true

	def getBoidsQuantity() : int {
		boids_quantity_input.value as int
	}
	
	def getMapSelection() : int {
		map_selection_input.value as int
	}
	
	def getBoidsPopulation() : int {
		boids_population_input.value as int
	}
	
	def getBoidsVision() : int {
		boids_vision_input.value as int
	}
	
	def getMapWidth() : int {
		main_pane.width as int
	}
	
	def getMapHeight() : int {
		main_pane.height as int
	}
	
	def getObstacles() : List<Obstacle> {
		obstacles
	}
	
	def getBoidsDistanceDeplacement() : int {
		boids_distance_deplacement_input.value as int
	}
 
	@FXML protected def startSimu() : void {
		var ^event = new ConfigureSimulation(this.mapSelection, this.boidsQuantity, this.boidsPopulation, this.boidsVision)
		if (!launched) {
			startAgentApplication() [
				emitToAgents(^event)
			]
			launched = true
			mapCreated = false
			toggleUIState()
			toggleMenuUIVisibility()
			toggleSimuUIVisibility()
			toggle_night_mode.background = new Background(new BackgroundFill(Color.TRANSPARENT, CornerRadii.EMPTY, Insets.EMPTY))
			if(nightMode) {
				toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
			} else {
				toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
			}			
		} else {
			emitToAgents(^event)
		}
	}
	
	def buildMap(map : int) : List<Obstacle> {

		pause_button.visible = true

		if(map == 1) {
			return new ArrayList()
		}
		else if (map == 2) {
			this.polygons = new ArrayList()
			this.polygonsCoordinates = new ArrayList()
			this.obstacles = new ArrayList()
			this.polygons.add(new Polygon(250.0, 200.0, 365.0, 250.0, 400.0, 300.0, 325.0, 400.0, 205.0, 225.0))
			this.polygons.add(new Polygon(605.0, 80.0, 675.0, 65.0, 680.0, 125.0, 650.0, 220.0, 630.0, 250.0, 660.0, 130.0,
					665.0, 75.0, 615.0, 95.0, 560.0, 240.0, 560.0, 205.0, 605.0, 80.0))
			this.polygons.add(new Polygon(450.0, 450.0, 575.0, 500.0, 575.0, 420.0, 700.0, 500.0, 590.0, 450.0, 590.0, 520.0))
			this.polygons.forEach[p : Polygon |
				this.polygonsCoordinates.add(this.generateCoordinates(p))
				p.setFill(Color.GRAY)
				p.setStroke(Color.TRANSPARENT)
				p.setStrokeWidth(20)
			]

			var command = new Runnable() {
				@Override
				def run() {
					polygons.forEach [ p : Polygon |
						obstacle_group.getChildren().add(0, p)
					]
					/*System.out.println('LE TEST')
					var testcircle = new Circle(395, 310, 1)
					//System.out.println(polygons.get(0).contains(new Point2D(testcircle.centerX, testcircle.centerY)))
					obstacle_group.getChildren().add(0, testcircle)*/
				}
		};

			if (Platform.isFxApplicationThread()) {
				command.run();
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			} else {
				Platform.runLater(command);
				this.generateObstacles()
				// this.obstacles.forEach[o : Obstacle|System.out.println(o.toString())]
				return this.obstacles
			}
		}
	}
	
	def generateCoordinates(p : Polygon) : List<Coordinates> {
		var abscissa : AtomicDouble = new AtomicDouble();
		var coordinates : List<Coordinates> = new ArrayList()
		p.getPoints.forEach [ ordered : Double, index : int |
			if (index % 2 == 0) {
				abscissa.set(ordered)
			} else {
				coordinates.add(new Coordinates(abscissa.get(), ordered.doubleValue()))
			}
		]
		return coordinates
	}
	
	def generateObstacles() : void {
		this.polygonsCoordinates.forEach [p : List<Coordinates>, currentItem : int |
			var lines : List<LineTool> = new ArrayList()
			p.forEach[c : Coordinates, index : int |
				if(index != 0) {
					var line : LineTool = new LineTool(p.get(index - 1), c)
					line.computeLineEquation()
					lines.add(line)
				}
			]
			var line : LineTool = new LineTool(p.last, p.get(0))
			line.computeLineEquation()
			lines.add(line)
			this.obstacles.add(new Obstacle(lines, this.polygons.get(currentItem)))
		]
		
	}
	
	def updateGraphics(list: Collection<BoidBody>) : void {
		var command = new Runnable() {
			@Override
			def run() {
				boids_group.getChildren().clear()
				for (boid : list){
					var boidElement : Polygon = new Polygon(boid.position.x, boid.position.y - 7.5, boid.position.x + 5, boid.position.y + 7.5, boid.position.x - 5, boid.position.y + 7.5)
					boidElement.rotate = Math.toDegrees(Math.atan(boid.vitesse.x / boid.vitesse.y))
					boidElement.setFill(Configuration::COLOR_FAMILY.get(boid.groupe))
					
					boidElement.setOnMousePressed(new EventHandler<MouseEvent>() {
						def handle(^event : MouseEvent) {
							boid_group.text = 'Groupe: ' + boid.groupe
							boid_vitesse.text = 'Vitesse: (' + boid.vitesse.x + ', ' + boid.vitesse.y + ')' 
							boid_group_vitesse.text = 'Vitesse max. groupe: ' + boid.groupeVitesseMax
							boid_masse.text = 'Masse: ' + boid.masse
							boid_angle.text = 'Angle: ' + boid.angleVisibilite
							boid_distance.text = 'Distance percep.: ' + boid.distanceVisibilite
							boid_new_vitesse.text = 'Nouvelle vitesse: (' + boid.newVitesse.x + ', ' + boid.newVitesse.y + ')'
							showInfosVisibility()
						}
					}); 
					
					if(togglePerception) {
						// var perceptionRadius : Circle = new Circle(boid.position.x, boid.position.y, Double.parseDouble(boids_vision_display.text) * 80/100)
						var perceptionRadius : Circle = new Circle(boid.position.x, boid.position.y, Double.parseDouble(boids_distance_deplacement_display.text))
						// perceptionRadius.setStrokeWidth(Double.parseDouble(boids_vision_display.text) * 20/100)
						if(nightMode) {
							perceptionRadius.fill = Color.rgb(255, 245, 112, 0.2)
							// perceptionRadius.setStroke(Color.rgb(255, 255, 255, 0.1))
						} else {
							perceptionRadius.fill = Color.rgb(255, 245, 112, 0.8)
							// perceptionRadius.setStroke(Color.rgb(255, 255, 255, 0.5))
						}
						boids_group.getChildren().add(0, boidElement)
						boids_group.getChildren.add(0, perceptionRadius)
					} else {
						boids_group.getChildren.add(0, boidElement)
					}
					
				}
			}
		}
		
		if (Platform.isFxApplicationThread()) {
			command.run();
		} else {
			Platform.runLater(command);
		}	
	}

	@FXML protected def actionBoidsQuantityDisplay() : void {
		boids_quantity_input.valueProperty().addListener [
			boids_quantity_display.setText(String.format("%.0f", boids_quantity_input.getValue()));
		];
	}

	@FXML protected def actionMapSelectionDisplay() : void {
		map_selection_input.valueProperty().addListener [
			map_selection_display.setText(String.format("%.0f", map_selection_input.getValue()));
		];
	}

	@FXML protected def actionPopulationDisplay() : void {
		boids_population_input.valueProperty().addListener [
			boids_population_display.setText(String.format("%.0f", boids_population_input.getValue()));
		];
	}

	@FXML protected def actionBoidsVisionDisplay() : void {
		boids_vision_input.valueProperty().addListener [
			boids_vision_display.setText(String.format("%.0f", boids_vision_input.getValue()));
		];
	}

	@FXML protected def actionBoidsDistanceDeplacementDisplay() : void {
		boids_distance_deplacement_input.valueProperty().addListener [
			boids_distance_deplacement_display.setText(String.format("%.0f", boids_distance_deplacement_input.getValue()));
		];
	}
	
	@FXML protected def toggleMode() : void {
		if(nightMode) {
			nightMode = false
			night_mode_indicator.fill = Color.TRANSPARENT
			night_mode_indicator.stroke = Color.rgb(0, 0, 0, 0.3)
			perception_indicator.stroke = Color.rgb(0, 0, 0, 0.3)
			var normalTextColor : Color = Color.BLACK
			main_pane.background = new Background(new BackgroundFill(Color.TRANSPARENT, CornerRadii.EMPTY, Insets.EMPTY))
			boids_quantity_label.textFill = normalTextColor; boids_quantity_display.textFill = normalTextColor; boids_quantity_min.textFill = normalTextColor; boids_quantity_max.textFill = normalTextColor
			map_selection_label.textFill = normalTextColor;	map_selection_display.textFill = normalTextColor; map_min.textFill = normalTextColor; map_max.textFill = normalTextColor
			boids_population_label.textFill = normalTextColor; boids_population_display.textFill = normalTextColor; boids_population_min.textFill = normalTextColor; boids_population_max.textFill = normalTextColor
			boids_vision_label.textFill = normalTextColor; boids_vision_display.textFill = normalTextColor;	boids_vision_min.textFill = normalTextColor; boids_vision_max.textFill = normalTextColor
			
			boids_distance_deplacement_label.textFill = normalTextColor;
			boids_distance_deplacement_display.textFill = normalTextColor;
			boids_distance_deplacement_min.textFill = normalTextColor;
			boids_distance_deplacement_max.textFill = normalTextColor
			
			boid_group.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_group_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_masse.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_angle.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_distance.textFill = Color.rgb(0, 0, 0, 0.7)
			boid_new_vitesse.textFill = Color.rgb(0, 0, 0, 0.7)
			toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
			toggle_perception.textFill = Color.rgb(0, 0, 0, 0.3)
			hide_infos.textFill = Color.rgb(0, 0, 0, 0.3)
			start_button.textFill = normalTextColor
		} else {
			nightMode = true
			night_mode_indicator.fill = Color.rgb(0, 204, 99)
			night_mode_indicator.stroke = Color.rgb(184, 193, 207, 0.3)
			perception_indicator.stroke = Color.rgb(184, 193, 207, 0.3)
			var nightTextColor : Color = Color.rgb(191, 191, 191)
			main_pane.background = new Background(
			new BackgroundFill(Color.rgb(34, 34, 34), CornerRadii.EMPTY, Insets.EMPTY))
			boids_quantity_label.textFill = nightTextColor;	boids_quantity_display.textFill = nightTextColor; boids_quantity_min.textFill = nightTextColor;	boids_quantity_max.textFill = nightTextColor
			map_selection_label.textFill = nightTextColor; map_selection_display.textFill = nightTextColor;	map_min.textFill = nightTextColor;	map_max.textFill = nightTextColor
			boids_population_label.textFill = nightTextColor; boids_population_display.textFill = nightTextColor; boids_population_min.textFill = nightTextColor; boids_population_max.textFill = nightTextColor
			boids_vision_label.textFill = nightTextColor;
			boids_vision_display.textFill = nightTextColor;
			boids_vision_min.textFill = nightTextColor;
			boids_vision_max.textFill = nightTextColor

			boids_distance_deplacement_label.textFill = nightTextColor
			boids_distance_deplacement_display.textFill = nightTextColor
			boids_distance_deplacement_min.textFill = nightTextColor
			boids_distance_deplacement_max.textFill = nightTextColor
			
			boid_group.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_group_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_masse.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_angle.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_distance.textFill = Color.rgb(191, 191, 191, 0.7)
			boid_new_vitesse.textFill = Color.rgb(191, 191, 191, 0.7)
			toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
			toggle_perception.textFill = Color.rgb(191, 191, 191, 0.3)
			hide_infos.textFill = Color.rgb(191, 191, 191, 0.3)
			start_button.textFill = nightTextColor
		}
	}
	
	@FXML protected def togglePerception() : void {
		if(togglePerception) {
			togglePerception = false
			perception_indicator.fill = Color.TRANSPARENT
		} else {
			togglePerception = true
			perception_indicator.fill = Color.rgb(0, 204, 99)
		}
	}
	
	@FXML protected def toggleButtonGlow() : void {	
		if(nightMode)
			toggle_night_mode.textFill = Color.rgb(235, 221, 26)
		else
			toggle_night_mode.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		toggle_night_mode.effect = glowEffect
	}
	
	@FXML protected def toggleButtonReset() : void {
		if(launched) {
			if (nightMode)
				toggle_night_mode.textFill = Color.rgb(191, 191, 191, 0.3)
			else
				toggle_night_mode.textFill = Color.rgb(0, 0, 0, 0.3)
		} else {
			if (nightMode)
				toggle_night_mode.textFill = Color.rgb(191, 191, 191)
			else
				toggle_night_mode.textFill = Color.rgb(0, 0, 0)
		}
		toggle_night_mode.effect = null
	}

	@FXML protected def startButtonGlow() : void {
		if (nightMode)
			start_button.textFill = Color.rgb(235, 221, 26)
		else
			start_button.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		start_button.effect = glowEffect
	}

	@FXML protected def startButtonReset() : void {
		if (nightMode)
			start_button.textFill = Color.rgb(191, 191, 191)
		else
			start_button.textFill = Color.rgb(0, 0, 0)
		start_button.effect = null
	}
	
	@FXML protected def perceptionButtonGlow() : void {
		if (nightMode)
			toggle_perception.textFill = Color.rgb(235, 221, 26)
		else
			toggle_perception.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		toggle_perception.effect = glowEffect
	}
	
	@FXML protected def perceptionButtonReset() : void {
		if (nightMode)
			toggle_perception.textFill = Color.rgb(191, 191, 191, 0.3)
		else
			toggle_perception.textFill = Color.rgb(0, 0, 0, 0.3)
		toggle_perception.effect = null
	}
	
	@FXML protected def infosButtonGlow() : void {
		if (nightMode)
			hide_infos.textFill = Color.rgb(235, 221, 26)
		else
			hide_infos.textFill = Color.rgb(0, 0, 0)
		var glowEffect = new Glow()
		glowEffect.level = 0.8
		hide_infos.effect = glowEffect
	}
	
	@FXML protected def infosButtonReset() : void {
		if (nightMode)
			hide_infos.textFill = Color.rgb(191, 191, 191, 0.3)
		else
			hide_infos.textFill = Color.rgb(0, 0, 0, 0.3)
		hide_infos.effect = null
	}
	
	def toggleUIState() : void {
		if(start_button.disable == true) start_button.disable = false else start_button.disable = true
		if(boids_quantity_input.disable == true) boids_quantity_input.disable = false else boids_quantity_input.disable = true
		if(map_selection_input.disable == true) map_selection_input.disable = false else map_selection_input.disable = true
		if(boids_population_input.disable == true) boids_population_input.disable = false else boids_population_input.disable = true
		if(boids_vision_input.disable == true) boids_vision_input.disable = false else boids_vision_input.disable = true

		if(boids_distance_deplacement_input.disable == true) boids_distance_deplacement_input.disable = false else boids_distance_deplacement_input.disable = true
		// if(toggle_night_mode.disable == true)  toggle_night_mode.disable = false else toggle_night_mode.disable = true
	}
	
	def toggleMenuUIVisibility() : void {
		if(UI_pane.visible) UI_pane.visible = false else UI_pane.visible = true
	}
	
	def toggleSimuUIVisibility() : void {
		if(!toggle_perception.visible) toggle_perception.visible = true else toggle_perception.visible = false
		if(!perception_indicator.visible) perception_indicator.visible = true else perception_indicator.visible = false
	}
	
	@FXML def pause() : void {
		pause_button.visible = false
		resume_button.visible = true
		emitToAgents(new Pause)
	}
	
	@FXML def resume() : void {
		pause_button.visible = true
		resume_button.visible = false
		emitToAgents(new Resume)
	}
	
	def hideInfosVisibility() : void {
		this.resetTexts()
		boids_infos_pane.visible = false
		boids_infos_pane.disable = true
		/*boid_group.visible = false
		boid_vitesse.visible = false
		boid_group_vitesse.visible = false
		boid_masse.visible = false
		boid_angle.visible = false
		boid_distance.visible = false
		boid_new_vitesse.visible = false
		hide_infos.visible = false*/
	}
	
	def resetTexts() : void {
		boid_group.text = ''
		boid_vitesse.text = ''
		boid_group_vitesse.text = ''
		boid_masse.text = ''
		boid_angle.text = ''
		boid_distance.text = ''
		boid_new_vitesse.text = ''
	}

	def showInfosVisibility() : void {
		boids_infos_pane.visible = true
		boids_infos_pane.disable = false
		/*boid_group.visible = true
		boid_vitesse.visible = true
		boid_group_vitesse.visible = true
		boid_masse.visible = true
		boid_angle.visible = true
		boid_distance.visible = true
		boid_new_vitesse.visible = true
		hide_infos.visible = true*/
	}
}
